Программа получает команды из стандартного потока ввода или из файла. Эти команды обеспечивают построение композиции геометрических фигур на плоскости. Программа также умеет подсчитывать координаты прямоугольника, описывающего все фигуры в сцене, стороны которого параллельны системе координат.

Большая часть функционала реализована не полностью. Допишите программу используя приведённое ниже описание.

Поддерживаемые команды:

Команды для добавления фигур
add rectangle {имя} (0, 0) (1, 1)
добавляет в композицию прямоугольник, стороны которого параллельны осям координат, а противоположные вершины заданы координатами.

Имя фигуры представляет собой последовательность букв или цифр или знака нижнего подчеркивания или знака ‘-’

add circle {имя} (0, 0) radius 12

добавляет в композицию окружность, центр которой задан координатами и радиусом

add polygon {имя}
 add point (0, 1)
 add point (2, 2)
 add point (-1, 2)
end polygon
добавляет в композицию многоугольник, описанный координатами точек, самопересечение не допускается

Команды для изменения фигур:

group {имя1}, … {имяN} as {имя группы}

объединяет несколько фигур как одно целое, известное под именем {имя группы}, после выполнения этой команды любые команды для работы с фигурами должны работать и с именем объединенной фигуры

delete ({имя}|scene)

удаляет фигуру или всю сцену

copy ({имя}|scene) to {имя_копии}

копирует фигуру или всю сцену и называет новый объект {имя_копии}

move ({имя}|scene) (10, 2)

перемещает фигуру на вектор

rotate ({имя}|scene) 45

вращает фигуру на угол относительно центра

reflect (vertically|horizontally) ({имя}|scene)

отражает фигуру относительно центра фигуры вертикально или горизонтально

Команды для печати текущих параметров композиции:

print circumscribing rectangle for ({имя}|scene)

печатает координаты верхней левой и нижней правой вершины прямоугольника, стороны которого параллельны осям координат, описанного вокруг фигуры

Дополнительные требования:

Если найдены какие-либо ошибки в входном файле, то программа должна сообщать о них.

Когда программа находит пустую строку, она заканчивает работу

Допустимо использовать комментарии в конце строки вида: # any symbols

Допустима строка без команды, но с комментарием.

Формат сообщений об ошибках:

error in line NN: {сообщение об ошибке}
Варианты сообщений об ошибках:

bad format

когда невозможно распознать формат команды

bad rectangle point

когда точки не задают прямоугольник

bad circle radius

когда радиус окружности <= 0

bad polygon point

когда точка полигона совпадает с одной из предыдущих или образует пересечение с одной из предыдущих сторон

bad polygon point number

когда количество вершин полигона < 3

unexpected end of polygon

когда отсутствует end polygon

bad name

когда в команде изменения используется несуществующее имя

name does already exist

когда в команде добавления/копирования используется уже существующее имя

Рекомендованная последовательность выполнения работы:

Откройте файл Program.cs изучите логику основного цикла приложения. Обратите внимание, программа может читать команды из файла, для этого нужно передать путь (абсолютный или относительный) как аргумент исполняемого файла. Если путь не передаётся, то программа запрашивает команды в консоли. При вводе команд в консоли после каждой команды происходит отрисовка сцены в файл scene.png. При выполнении команд из файла отрисовка происходит один раз — после самой последней команды. Логика отрисовки уже реализована и не требует изменений.

Откройте файл Figures\Rectangle.cs, содержащий заготовку для описания прямоугольника. Реализуйте метод CalculateCircumscribingRectangle в классе Rectangle.

Ознакомьтесь с логикой работы класса CommandBuilders\CommandProducer. Допишите код класса AddRectangleCommandBuilder, чтобы он осуществлял распознавание команды add rectangle …​. Для поиска соответствия команде здесь и далее удобно использовать Regex, прямые операции со строками, либо комбинацию этих подходов. Классы …​CommandBuilder должны отвечать за проверку введённых данных и выбрасывать исключения, если возникают проблемы.

Если изменения внесены корректно, то мы получили минимально-рабочую версию программы. Запустите приложение, в качестве команды введите:

add rectangle TEST1 (-100, -20) (100, 20)
Откройте файл bin\Debug\netcoreapp%VERSION%\scene.png, Вы должны увидеть голубой прямоугольник на сером фоне. Попробуйте ввести больше команд add rectangle …​, (имена должны отличаться) убедитесь, что прямоугольники корректно позиционируются и отрисовываются.

В папке Figures есть заготовки для фигур Circle и Polygon с реализованной логикой отрисовки. Реализуйте IFigure в каждом из этих классов по аналогии с Rectangle, первым делом реализуйте CalculateCircumscribingRectangle, в остальных методах пока можно оставить "заглушки".

Создайте классы AddCircleCommandBuilder и AddPolygonCommandBuilder в папке CommandBuilders. Не забудьте зарегистрировать их в классе CommandProducer.

Теперь приложение должно уметь рисовать не только прямоугольники, но и остальные фигуры. Попробуйте выполнить команды из файла TestInputs\smile.txt, проверьте, что отрисовалось на scene.png.

Реализуйте методы Move, Rotate и Reflect во всех фигурах и в классе Scene, добавьте соответствующие CommandBuilder-классы, зарегистрируйте их в CommandProducer. Также нам потребуется создать команды (MoveCommand, RotateCommand, ReflectCommand) в папке Commands по аналогии с AddFigureCommand.

Создайте свой класс (например, CompositeFigure), реализующий интерфейс ICompositeFigure, организуйте хранение таких фигур (групп) в сцене и поддержку команд группировки. Измените код класса Scene, чтобы команды переноса, поворота и отражения работали и для групп. Чтобы упростить реализацию, будем считать, что операции отражения и поворота для группы работают на каждой фигуре внутри этой группы отдельно.

Реализуйте команды копирования и удаления фигуры/группы/сцены, а также команду print circumscribing rectangle …​.

Запустите приложение, поэкспериментируйте с входными командами, попробуйте создать и выполнить файл с командами, который выдаёт осмысленный рисунок на выходе. Добавьте этот файл в папку TestInputs. Залейте готовую программу в GIT.